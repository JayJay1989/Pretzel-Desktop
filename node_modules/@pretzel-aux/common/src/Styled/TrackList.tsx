import * as React from 'react';
import { Box, Heading } from 'grommet';
import { ClipLoader } from 'halogenium';
import { compose, withMutation } from 'react-apollo';
import styled from 'styled-components/macro';
import { BasicTrack, PlayToken } from '../Core/Player/Queries/schema';
import { PlayerContext, withPlayerContext } from '../Core/Player/PlayerContext';
import { loader } from 'graphql.macro';
import { Mutation } from '../Core/GraphQL';
import {
  SetTrackBlacklistedInput,
  SetTrackBlacklistedMutation,
  SetTrackLikedInput,
  SetTrackLikedMutation,
} from '../Core/Player/Components/PlayerControls/schema';
import { Analytics, AnalyticsEventResourceType, AnalyticsEventType } from '../Core/Analytics';
import { LoadMoreButton } from './LoadMoreButton';
import { SettingsContext, SettingsKeys, withSettingsContext } from '../Core/Settings/Settings';
import { Night } from './SlobsColors';
import { PretzelColors } from './PretzelColors';
import { CopyToClipboard, formatTime, joinStringsGrammatically } from '../Util';
import { Icon } from './Icon';
import { PlatformContext, withPlatformContext } from '../Core/Platform';

const likeTrackMutation = loader('../Core/Player/Queries/set-track-liked.graphql');
const blacklistTrackMutation = loader('../Core/Player/Queries/set-track-blacklisted.graphql');

interface PublicProps {
  title: string;
  tracks: BasicTrack[];
  loading: boolean;
  hasMore: boolean;
  onMore: () => void;
  loadingMore: boolean;
}

type PropsFromPlatform = Pick<PlatformContext, 'pretzelUser'>;
type PropsFromPlayerContext = Pick<PlayerContext, 'playToken' | 'playTrack' | 'next'>;
type PropsFromSettingsContext = Pick<
  SettingsContext,
  SettingsKeys.InstrumentalOnly | SettingsKeys.AllowExplicit | SettingsKeys.YoutubeSafe
>;

interface GraphQLProps {
  likeTrack: Mutation<SetTrackLikedInput, SetTrackLikedMutation>;
  blacklistTrack: Mutation<SetTrackBlacklistedInput, SetTrackBlacklistedMutation>;
}

type Props = PublicProps & PropsFromPlayerContext & PropsFromSettingsContext & PropsFromPlatform & GraphQLProps;

const StyledRow = styled('tr')`
  td {
    border-bottom: 1px solid ${Night.bgSectionsAlt};
  }

  &:first-of-type td {
    border-top: 1px solid ${Night.bgSectionsAlt};
  }

  &:hover {
    color: ${PretzelColors.brandGreen};
  }
`;

class TrackListPresentation extends React.Component<Props> {
  public render() {
    return (
      <div style={{ overflow: 'auto', padding: '30px' }}>
        <Heading level="2">{this.props.title}</Heading>
        <table>
          <tbody>{this.renderTracks()}</tbody>
        </table>
        <Box justify="center" align="center" margin="20px">
          {this.props.hasMore && <LoadMoreButton onMore={this.props.onMore} loading={this.props.loadingMore} />}
          {this.props.loading && <ClipLoader color={PretzelColors.brandGreen} size="16px" />}
        </Box>
      </div>
    );
  }

  private renderTracks() {
    if (this.props.loading && !this.props.tracks) {
      return this.renderPlaceholders();
    }
    const { allowExplicit, youtubeSafe, instrumentalOnly } = this.props;

    return this.props.tracks.map((track, i) => {
      const explicitForbidden: boolean = !!track.explicit && !allowExplicit;
      const youtubeForbidden: boolean = !track.youtubeSafe && youtubeSafe;
      const instrumentalForbidden: boolean = !track.instrumental && instrumentalOnly;
      const freeTierForbidden = !this.props.pretzelUser.premium;
      const forbidden: boolean =
        explicitForbidden || youtubeForbidden || instrumentalForbidden || track.self.blacklisted || freeTierForbidden;

      if (forbidden) {
        return (
          <ForbiddenTrackItem
            track={track}
            index={i}
            key={track.id}
            likeTrack={this.props.likeTrack}
            blacklistTrack={this.props.blacklistTrack}
            youtubeRestricted={youtubeForbidden}
            explicitRestricted={explicitForbidden}
            instrumentalRestricted={instrumentalForbidden}
            blacklisted={track.self.blacklisted}
            freeTierRestricted={freeTierForbidden}
          />
        );
      } else {
        return (
          <TrackItem
            track={track}
            index={i}
            key={track.id}
            likeTrack={this.props.likeTrack}
            blacklistTrack={this.props.blacklistTrack}
            playToken={this.props.playToken}
            playTrack={this.props.playTrack}
            next={this.props.next}
          />
        );
      }
    });
  }

  private renderPlaceholders() {
    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(i => (
      <StyledRow key={i}>
        <td>{i + 1}</td>
        <td />
        <td>... Loading...</td>
        <td />
        <td />
        <td>-:--</td>
      </StyledRow>
    ));
  }
}

function sendAnalyticsEvent(type: AnalyticsEventType, track: BasicTrack) {
  Analytics.captureEvent({
    type,
    source: 'tracklist',
    resource: {
      type: AnalyticsEventResourceType.Track,
      guid: track.id,
    },
  });
}

interface TrackItemProps {
  playToken: PlayToken | null;
  track: BasicTrack;
  index: number;
  next: () => void;
  playTrack: (track: BasicTrack) => void;
  likeTrack: Mutation<SetTrackLikedInput, SetTrackLikedMutation>;
  blacklistTrack: Mutation<SetTrackBlacklistedInput, SetTrackBlacklistedMutation>;
}

interface TrackItemState {
  open: boolean;
  loadingLike: boolean;
  loadingBlacklist: boolean;
}

const DropdownBox = styled.div`
  padding-top: 7px;
  position: absolute;
  top: 20px;
  right: 0;
  min-width: max-content;
  z-index: 2;
  display: flex;
  text-align: left;
  font-size: 12px;

  div {
    box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.2);
  }
`;

const DropdownItem = styled(Box)`
  padding: 4px 16px;
  cursor: pointer;

  :hover {
    background: ${Night.bgSectionsAlt};
  }
`;

const HoverShow = styled.span`
  display: none;

  ${StyledRow}:hover & {
    display: inline;
  }
`;
const HoverHide = styled.span`
  ${StyledRow}:hover & {
    display: none;
  }
`;

const TopTail = styled.div`
  position: absolute;
  top: 0;
  right: 4px;
  width: 0;
  height: 0;
  border-left: 7px solid transparent;
  border-right: 7px solid transparent;
  border-bottom: 7px solid ${Night.bgSections};
`;

class TrackItem extends React.Component<TrackItemProps, TrackItemState> {
  state: TrackItemState = {
    open: false,
    loadingLike: false,
    loadingBlacklist: false,
  };

  public render() {
    const { track, index, playToken } = this.props;
    const { open, loadingBlacklist, loadingLike } = this.state;
    const isPlaying = playToken && playToken.track.id === track.id;
    const firstColumnContents = isPlaying ? (
      <Icon name="volume_3" size={16} />
    ) : (
      <>
        <HoverHide>{(index + 1).toString()}</HoverHide>
        <HoverShow>
          <Icon name="tracklist_play" size={16} />
        </HoverShow>
      </>
    );
    return (
      <StyledRow key={`sr-${track.id}`} onClick={this.onClick}>
        <td style={{ width: '46px', textAlign: 'center' }}>{firstColumnContents}</td>
        <td>{track.title}</td>
        <td>{joinStringsGrammatically(track.artists.map(a => a.name))}</td>
        <td>{track.album && track.album.title}</td>
        <td>
          <Box onClick={this.onClickMenu} style={{ position: 'relative', textAlign: 'right' }} focusIndicator={false}>
            <Icon name="more" size={20} />
            {open && (
              <DropdownBox>
                <TopTail />
                <Box background={Night.bgSections} pad={{ vertical: '8px' }}>
                  <DropdownItem onClick={this.handleCopy}>Copy Song Link</DropdownItem>
                  <Box border="bottom" margin={{ vertical: '8px' }} />
                  <DropdownItem justify="between" direction="row" onClick={this.handleLike}>
                    <span>Like</span>
                    {loadingLike && <ClipLoader color={PretzelColors.brandGreen2} size="12px" />}
                    {track.self.liked && (
                      <span>
                        <Icon name="checkmark" size={12} />
                      </span>
                    )}
                  </DropdownItem>
                  <DropdownItem justify="between" direction="row" onClick={this.handleBlacklist}>
                    <span>Blacklist</span>
                    {loadingBlacklist && <ClipLoader color={PretzelColors.brandGreen2} size="12px" />}
                    {track.self.blacklisted && (
                      <span>
                        <Icon name="checkmark" size={12} />
                      </span>
                    )}
                  </DropdownItem>
                </Box>
              </DropdownBox>
            )}
          </Box>
        </td>
        <td>{formatTime(track.duration)}</td>
      </StyledRow>
    );
  }

  private onClick = () => {
    console.debug('Immediately Playing', this.props.track);
    this.props.playTrack(this.props.track);
  };

  private onClickMenu = (event: React.MouseEvent) => {
    event.stopPropagation(); // Don't trigger the row's `onClick`
    this.setState({ open: true }, () => {
      document.addEventListener('click', this.onClickOut);
    });
  };

  private onClickOut = () => {
    this.setState({ open: false }, () => {
      document.removeEventListener('click', this.onClickOut);
    });
  };

  private handleCopy = (event: React.MouseEvent<any>) => {
    CopyToClipboard(`https://prtzl.to/${this.props.track.id}`);
  };

  private handleLike = (event: React.MouseEvent<any>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    if (this.props.playToken) {
      this.setState({ loadingLike: true });
      this.props
        .likeTrack({
          variables: {
            trackId: this.props.track.id,
            value: !this.props.track.self.liked,
          },
        })
        .then(() => this.setState({ loadingLike: false }))
        .catch(() => this.setState({ loadingLike: false }));
      sendAnalyticsEvent(AnalyticsEventType.Like, this.props.track);
    }
  };

  private handleBlacklist = (event: React.MouseEvent<any>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    if (this.props.playToken) {
      this.setState({ loadingBlacklist: true });
      this.props
        .blacklistTrack({
          variables: {
            trackId: this.props.track.id,
            value: !this.props.track.self.blacklisted,
          },
        })
        .then(() => {
          this.setState({ loadingBlacklist: false });
          if (this.props.playToken && this.props.playToken.track.id === this.props.track.id) {
            this.props.next();
          }
        })
        .catch(() => this.setState({ loadingBlacklist: false }));
      sendAnalyticsEvent(AnalyticsEventType.Blacklist, this.props.track);
    }
  };
}

const ForbiddenRow = styled('tr')`
  td {
    border-bottom: 1px solid ${Night.bgSectionsAlt};
    color: #909090;
    font-style: italic;
  }

  td.reason {
    text-decoration: none;
  }

  &:first-of-type td {
    border-top: 1px solid ${Night.bgSectionsAlt};
  }
`;

const ForbiddenIcon = styled.i`
  color: ${PretzelColors.brandGreen2};
  font-size: 20px;
  height: 20px;
  cursor: default;
`;
const StyledButton = styled('button')`
  padding: 0;
  border: none;
  height: 20px;
  width: 20px;
  font-size: 20px;
  margin: 6px;
  text-align: center;
  background: transparent;
  color: ${PretzelColors.baseWhite};
  cursor: pointer;
  &:hover {
    color: ${PretzelColors.brandGreen2};
  }
  z-index: 3;
  position: relative;
`;

interface ForbiddenTrackItemProps {
  track: BasicTrack;
  index: number;
  key: string;
  blacklistTrack: Mutation<SetTrackBlacklistedInput, SetTrackBlacklistedMutation>;
  youtubeRestricted: boolean;
  instrumentalRestricted: boolean;
  explicitRestricted: boolean;
  blacklisted: boolean;
  freeTierRestricted: boolean;
}

class ForbiddenTrackItem extends React.Component<ForbiddenTrackItemProps & GraphQLProps, TrackItemState> {
  public render() {
    const {
      track,
      index,
      youtubeRestricted,
      instrumentalRestricted,
      explicitRestricted,
      blacklisted,
      freeTierRestricted,
    } = this.props;

    let youtubeContent;
    if (youtubeRestricted) {
      youtubeContent = (
        <ForbiddenIcon
          className={'pretzel-icon-youtube-safe'}
          title="This track is not safe for YouTube, and you have the YouTube Safe filter turned on"
        />
      );
    }
    let instrumentalContent;
    if (instrumentalRestricted) {
      instrumentalContent = (
        <ForbiddenIcon
          className={'pretzel-icon-no-vocals'}
          title="This track has vocals, and you have the Instrumental Only filter turned on"
        />
      );
    }
    let explicitContent;
    if (explicitRestricted) {
      explicitContent = (
        <ForbiddenIcon
          style={{ color: '#a4a4a4' }}
          className={'pretzel-icon-explicit'}
          title="This track is explicit, and you have the Allow Mature filter turned off"
        />
      );
    }
    let blacklistContent;
    if (blacklisted) {
      blacklistContent = (
        <StyledButton onClick={this.handleBlacklist} title="Remove from Blacklist">
          <Icon name="thumbs_down" size={18} isDisabled={false} />
        </StyledButton>
      );
      // blacklistContent = <ForbiddenIcon
      //   className={'pretzel-icon-thumbs_down'}
      //   title="This track has been disliked" />
    }
    let freeTierContent;
    if (freeTierRestricted) {
      freeTierContent = (
        <ForbiddenIcon
          className={'pretzel-icon-radio'}
          title="Free Tier users are not able to play individual songs. Upgrade to premium by clicking this icon next to the player"
        />
      );
    }

    return (
      <ForbiddenRow key={`sr-${track.id}`} title="This track is disabled due to filters">
        <td style={{ width: '46px', textAlign: 'center', fontStyle: 'normal' }}>{(index + 1).toString()}</td>
        <td>{track.title}</td>
        <td>{joinStringsGrammatically(track.artists.map(a => a.name))}</td>
        <td>{track.album && track.album.title}</td>
        <td className="reason" colSpan={4}>
          {instrumentalContent}
          {youtubeContent}
          {explicitContent}
          {blacklistContent}
          {freeTierContent}
        </td>
      </ForbiddenRow>
    );
  }

  private handleBlacklist = (event: React.MouseEvent<any>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    this.props.blacklistTrack({
      variables: {
        trackId: this.props.track.id,
        value: !this.props.track.self.blacklisted,
      },
    });
    sendAnalyticsEvent(AnalyticsEventType.Blacklist, this.props.track);
  };
}

function mapPlayerContextToProps(c: PlayerContext): PropsFromPlayerContext {
  return {
    playToken: c.playToken,
    playTrack: c.playTrack,
    next: c.next,
  };
}

function mapSettingsContextToProps(c: SettingsContext): PropsFromSettingsContext {
  return {
    instrumentalOnly: c.instrumentalOnly,
    allowExplicit: c.allowExplicit,
    youtubeSafe: c.youtubeSafe,
  };
}

function mapPlatformToProps(c: PlatformContext): PropsFromPlatform {
  return {
    pretzelUser: c.pretzelUser,
  };
}

export const TrackList: React.ComponentClass<PublicProps> = compose(
  withPlatformContext(mapPlatformToProps),
  withSettingsContext(mapSettingsContextToProps),
  withPlayerContext(mapPlayerContextToProps),
  withMutation(likeTrackMutation, { name: 'likeTrack' }),
  withMutation(blacklistTrackMutation, { name: 'blacklistTrack' }),
)(TrackListPresentation);
