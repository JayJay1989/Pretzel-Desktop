import React, { useState } from 'react';
import { Box, Button, Image, Text, Heading } from 'grommet';
import { graphql, QueryControls } from '@apollo/client/react/hoc';
import { flowRight as compose } from 'lodash';
import { withRouter, match } from 'react-router';
import { ClipLoader } from 'halogenium';
import { loader } from 'graphql.macro';
import { Night, PretzelColors, red, TrackList } from '../../Styled';
import { minutesOrHours, toUrl } from '../../Util';
import { SegmentQuery } from './types/SegmentQuery';
import { BasicTrackFragment } from '../../Core/Player/Queries/types/BasicTrackFragment';
import './style.css';
import { StationArt } from '../../Styled/StationArt';
import styled from 'styled-components/macro';
import { PlayerContext, withPlayerContext } from '../../Core/Player/PlayerContext';
import { UploadButton } from '../../../../assets/icons';
import Clipboard from 'react-clipboard.js';
import ReactTooltip from 'react-tooltip';
import { useMutation } from '@apollo/client';
import { useHistory } from 'react-router-dom';
import {
  PlayerControlsDeletePlaylist,
  PlayerControlsDeletePlaylistVariables,
} from './types/PlayerControlsDeletePlaylist';
import { PlaylistsListQuery } from '../PlaylistsList/types/PlaylistsListQuery';
import { UserPlaylistsListQuery } from '../PlaylistsList/types/UserPlaylistsListQuery';

const segmentGql = loader('./segment.graphql');
const deletePlaylistGql = loader('./delete-playlist.graphql');
const userPlaylistsGql = loader('../PlaylistsList/userPlaylists.graphql');

interface ParamProps {
  segmentId: string;
  trackId?: string;
}

interface RouterProps {
  match: match<ParamProps>;
}

interface GraphqlProps {
  data: QueryControls & SegmentQuery;
}

type PropsFromPlayer = Pick<PlayerContext, 'playSegment' | 'activeSegment' | 'showModal' | 'closeModal'>;

type Props = GraphqlProps & RouterProps & PropsFromPlayer;

export const StyledButton = styled('button')`
  padding: 0;
  border: none;
  cursor: pointer;
  background: transparent;
  color: ${PretzelColors.baseWhite};
  &:hover {
    color: ${PretzelColors.brandGreen2};
  }
`;

export const StyledClipboard = styled(Clipboard)`
  padding: 0;
  border: none;
  cursor: pointer;
  background: transparent;
  color: ${PretzelColors.baseWhite};
  &:hover {
    color: ${PretzelColors.brandGreen2};
  }
`;

function SegmentImplementation(props: Props) {
  const { data } = props;

  const [loadingMore, setLoadingMore] = useState(false);
  const [deletePlaylist] = useMutation<PlayerControlsDeletePlaylist, PlayerControlsDeletePlaylistVariables>(
    deletePlaylistGql,
    {
      update: (cache, mutationResult) => {
        const cacheData = cache.readQuery<UserPlaylistsListQuery>({ query: userPlaylistsGql });
        const edges = cacheData.userPlaylists.edges.filter(value => value.node.id !== data.segment.id);
        const userPlaylists = {
          ...cacheData.userPlaylists,
          edges,
        };
        cache.writeQuery({
          query: userPlaylistsGql,
          data: { userPlaylists },
        });
      },
    },
  );
  const history = useHistory();

  function handlePlay() {
    props.playSegment({ id: props.match.params.segmentId });
  }

  function handleDelete() {
    if (data.segment.__typename === 'Playlist') {
      props.showModal(renderDeleteModal(), false);
    }
  }

  function renderDeleteModal(): React.ReactNode {
    return (
      <>
        <Heading level="2" style={{ color: 'white' }}>
          Are you sure you want to delete this playlist?
        </Heading>
        <Button
          style={{ color: 'white', marginRight: 10 }}
          size="small"
          plain={false}
          primary={false}
          color="control"
          onClick={props.closeModal}
        >
          Cancel
        </Button>
        <Button
          style={{ color: 'white' }}
          size="small"
          plain={false}
          primary={true}
          color={red}
          onClick={actuallyDeletePlaylist}
          title="Delete"
        >
          Delete
        </Button>
      </>
    );
  }

  function actuallyDeletePlaylist() {
    props.closeModal();
    if (data.segment.__typename === 'Playlist') {
      deletePlaylist({ variables: { id: data.segment.id } }).then(() => {
        history.push('/playlists');
      });
    }
  }

  function onMore() {
    const guid = props.match.params.segmentId;
    const after = props.data.segment.tracks.pageInfo.endCursor || '';
    console.debug('Loading More', {
      type: 'segment tracks',
      currentLength: props.data.segment.tracks.edges.length,
      guid,
      after,
    });
    setLoadingMore(true);

    props.data.fetchMore({
      variables: { guid, after },
      updateQuery: (previousQueryResult: SegmentQuery, { fetchMoreResult }) => {
        setLoadingMore(false);
        if (!fetchMoreResult) {
          return previousQueryResult;
        }
        return {
          segment: {
            ...previousQueryResult.segment,
            tracks: Object.assign({}, fetchMoreResult.segment.tracks, {
              edges: [...previousQueryResult.segment.tracks.edges, ...fetchMoreResult.segment.tracks.edges],
            }),
          },
        };
      },
    });
  }

  if (data.loading) {
    return <ClipLoader color={PretzelColors.brandGreen} size="16px" />;
  }
  if (data.error) {
    throw data.error;
  }
  let art = null;
  let subHeaderText = '';
  let playlistId = undefined;
  switch (data.segment.__typename) {
    case 'Album':
      art = <Image src={toUrl(data.segment.artworkGuid)} width="100%" />;
      break;
    case 'Artist':
      art = <Image src={toUrl(data.segment.artworkGuid)} width="100%" style={{ borderRadius: '50%' }} />;
      break;
    case 'Label':
      art = <Image src={toUrl(data.segment.artworkGuid)} width="100%" style={{ borderRadius: '50%' }} />;
      break;
    case 'Station':
      console.log('!!!', data.segment);
      art = <StationArt color1={data.segment.color1} color2={data.segment.color2} theIcon={data.segment.icon} />;
      subHeaderText = data.segment.description;
      break;
    case 'Playlist':
      playlistId = data.segment.id;
      art = <Image src={toUrl(data.segment.artworkGuid)} width="100%" />;
      subHeaderText = data.segment.description;
      break;
    case 'Mix':
      break;
  }

  const tracks: BasicTrackFragment[] = data.segment.tracks.edges.map(t => t.node);
  const hasMore = data.segment.tracks.pageInfo.hasNextPage;
  const stats = data.segment.stats;

  let shareUrl: string = `https://play.pretzel.rocks/segment/${props.match.params.segmentId}`;
  if (process.env.REACT_APP_CONTEXT !== 'production' && process.env.REACT_APP_DEPLOY_PRIME_URL) {
    shareUrl = `${process.env.REACT_APP_DEPLOY_PRIME_URL}/segment/${props.match.params.segmentId}`;
  }

  return (
    <div style={{ overflow: 'auto', padding: '30px' }}>
      <Box direction="row" margin={{ bottom: 'small' }}>
        <Box width="xsmall">{art}</Box>
        <Box pad="xsmall">
          <Text as="p" margin="none" size="xsmall">
            {data.segment.__typename}:
          </Text>
          <Heading level="2" margin="none">
            {data.segment.name}
          </Heading>
          <Text as="p" margin="none">
            {subHeaderText}
          </Text>
        </Box>
      </Box>
      <Box direction="row">
        <Button
          style={{ color: 'white' }}
          size="small"
          margin={{ right: '10' }}
          plain={false}
          primary={true}
          color="control"
          onClick={handlePlay}
        >
          Play
        </Button>
        <ReactTooltip />
        &nbsp;&nbsp;&nbsp;
        <StyledClipboard
          data-tip="Copied!"
          data-text-color={PretzelColors.brandGreen2}
          data-background-color={Night.bgSectionsAlt}
          data-place="right"
          data-event="click"
          data-event-off="mouseout"
          data-delay-show={100}
          data-clipboard-text={shareUrl}
          onSuccess={() => {}}
        >
          <UploadButton width={24} fill={PretzelColors.baseWhite} />
        </StyledClipboard>
        &nbsp;&nbsp;&nbsp;
        {data.segment.__typename === 'Playlist' && (
          <Button
            style={{ color: 'white' }}
            size="small"
            margin={{ left: '10' }}
            plain={false}
            primary={true}
            color={red}
            onClick={handleDelete}
            title="Delete"
          >
            Delete
          </Button>
        )}
      </Box>
      <Box>
        <Text as="p" style={{ paddingTop: '20px' }}>
          {stats.totalCount} tracks for a total of {minutesOrHours(stats.duration)} of music.
        </Text>
      </Box>

      <TrackList
        title="Tracks"
        fit="content"
        tracks={tracks}
        hasMore={hasMore}
        onMore={onMore}
        playlistId={playlistId}
        highlightId={props.match.params.trackId}
        loading={props.data.loading}
        loadingMore={loadingMore}
      />
    </div>
  );
}

function mapContextToProps(c: PlayerContext): PropsFromPlayer {
  return {
    activeSegment: c.activeSegment,
    playSegment: c.playSegment,
    showModal: c.showModal,
    closeModal: c.closeModal,
  };
}

export const Segment = compose(
  withRouter,
  withPlayerContext(mapContextToProps),
  graphql(segmentGql, {
    options: (props: RouterProps) => {
      return {
        // We want to refresh every time we navigate here, but this seems to cause the entire page to reload whenever
        // we are playing the segment and click "next"
        //fetchPolicy: 'cache-and-network',
        variables: {
          guid: props.match.params.segmentId,
        },
      };
    },
  }),
)(SegmentImplementation);
