import * as React from 'react';
import { compose, withMutation } from 'react-apollo';
import { Hoverable, Wrapper } from './Styles';
import { ControlItem } from './Components/ControlItem/ControlItem';
import { VolumeControl } from './Components/VolumeControl/VolumeControl';
import { loader } from 'graphql.macro';
import {
  SetTrackBlacklistedInput,
  SetTrackBlacklistedMutation,
  SetTrackLikedInput,
  SetTrackLikedMutation,
} from './schema';
import { PlayToken } from '../../Queries/schema';
import { AnalyticsEventType } from '../../../Analytics';
import { Mutation } from '../../../GraphQL';
import { PlayerContext, withPlayerContext } from '../../PlayerContext';
const likeTrackMutation = loader('../../Queries/set-track-liked.graphql');
const blacklistTrackMutation = loader('../../Queries/set-track-blacklisted.graphql');

interface PropsFromContext {
  playToken: PlayToken | null;
  loadingNext: boolean;
  playing: boolean;
  muted: boolean;
  audioVolume: number;
  next: () => void;
  togglePause: () => void;
  toggleMute: () => void;
  setVolume: (vol: number, instant?: boolean, faded?: boolean, visible?: boolean) => void;
  increaseVolume: () => void;
  decreaseVolume: () => void;
  sendAnalyticsEvent: (type: AnalyticsEventType, playToken?: PlayToken | null, source?: string) => void;
}

interface GraphQLProps {
  likeTrack: Mutation<SetTrackLikedInput, SetTrackLikedMutation>;
  blacklistTrack: Mutation<SetTrackBlacklistedInput, SetTrackBlacklistedMutation>;
}

type Props = PropsFromContext & GraphQLProps;

interface State {
  volumeBarVisible: boolean;
  loadingLike: boolean;
  loadingBlacklist: boolean;
}

class PlayerControlsPresentation extends React.Component<Props, State> {
  state = {
    volumeBarVisible: false,
    loadingLike: false,
    loadingBlacklist: false,
  };

  public render() {
    const { playToken } = this.props;
    return (
      <Wrapper>
        <ControlItem
          isLoading={this.state.loadingLike}
          isDisabled={this.props.loadingNext}
          active={playToken && playToken.track.self.liked}
          name="thumbs_up"
          onClick={this.handleLike}
        />
        <ControlItem
          isLoading={this.state.loadingBlacklist}
          isDisabled={this.props.loadingNext}
          active={playToken && playToken.track.self.blacklisted}
          name="thumbs_down"
          onClick={this.handleBlacklist}
        />
        <ControlItem
          isLoading={this.props.loadingNext}
          play
          isDisabled={false}
          style={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
          }}
          name={this.props.playing ? 'pause' : 'player_play'}
          onClick={this.handleTogglePause}
        />
        <ControlItem isLoading={this.props.loadingNext} isDisabled={false} name="next" onClick={this.handleNext} />
        <Hoverable
          style={{ margin: 6, width: 38 }}
          onMouseEnter={this.handleHoverable}
          onMouseLeave={this.handleHoverable}
        >
          <VolumeControl
            volumeBarVisible={this.state.volumeBarVisible}
            setVolume={this.props.setVolume}
            volume={this.props.audioVolume}
          />
          <ControlItem
            isLoading={false}
            isDisabled={false}
            style={{ margin: 0 }}
            name={
              this.props.muted
                ? 'mute'
                : this.props.audioVolume > 0.4
                ? this.props.audioVolume > 0.8
                  ? 'volume_3'
                  : 'volume_2'
                : 'volume'
            }
            onClick={this.handleMute}
          />
        </Hoverable>
      </Wrapper>
    );
  }

  public componentWillUnmount(): void {
    // @ts-ignore -- `removeEventListener` doesn't support passive:true
    document.removeEventListener('scroll', this.handleScroll, { passive: true });
  }

  private handleScroll = (event: WheelEvent) => {
    const direction = event.deltaY;
    if (direction) {
      if (direction < 0) {
        this.props.increaseVolume();
      } else if (direction > 0) {
        this.props.decreaseVolume();
      }
    }
  };

  private handleHoverable = () => {
    if (this.state.volumeBarVisible) {
      // @ts-ignore -- `removeEventListener` doesn't support passive:true
      document.removeEventListener('wheel', this.handleScroll, { passive: true });
    } else {
      document.addEventListener('wheel', this.handleScroll, { passive: true });
    }
    this.setState({ volumeBarVisible: !this.state.volumeBarVisible });
  };

  private handleLike = (event: React.MouseEvent<HTMLButtonElement>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    if (this.props.playToken) {
      this.setState({ loadingLike: true });
      this.props
        .likeTrack({
          variables: {
            trackId: this.props.playToken.track.id,
            value: !this.props.playToken.track.self.liked,
          },
        })
        .then(() => this.setState({ loadingLike: false }))
        .catch(() => this.setState({ loadingLike: false }));
      this.props.sendAnalyticsEvent(AnalyticsEventType.Like, this.props.playToken, 'playerControls');
    }
  };

  private handleBlacklist = (event: React.MouseEvent<HTMLElement>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    if (this.props.playToken) {
      this.setState({ loadingBlacklist: true });
      this.props
        .blacklistTrack({
          variables: {
            trackId: this.props.playToken.track.id,
            value: !this.props.playToken.track.self.blacklisted,
          },
        })
        .then(() => {
          this.setState({ loadingBlacklist: false });
          this.props.next();
        })
        .catch(() => this.setState({ loadingBlacklist: false }));
      this.props.sendAnalyticsEvent(AnalyticsEventType.Blacklist, this.props.playToken, 'playerControls');
    }
  };

  private handleTogglePause = (event: React.MouseEvent<HTMLElement>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    this.props.togglePause();
  };

  private handleNext = (event: React.MouseEvent<HTMLElement>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    this.props.next();
  };

  private handleMute = (event: React.MouseEvent<HTMLElement>) => {
    // @ts-ignore
    event.target.parentElement.blur();
    this.props.toggleMute();
  };
}

function mapContextToProps(c: PlayerContext): PropsFromContext {
  return {
    playToken: c.playToken,
    loadingNext: c.loadingNext,
    playing: c.playing,
    muted: c.muted,
    audioVolume: c.audioVolume,
    next: c.next,
    togglePause: c.togglePause,
    toggleMute: c.toggleMute,
    setVolume: c.setVolume,
    increaseVolume: c.increaseVolume,
    decreaseVolume: c.decreaseVolume,
    sendAnalyticsEvent: c.sendAnalyticsEvent,
  };
}

export const PlayerControls = compose(
  withPlayerContext(mapContextToProps),
  withMutation(likeTrackMutation, { name: 'likeTrack' }),
  withMutation(blacklistTrackMutation, { name: 'blacklistTrack' }),
)(PlayerControlsPresentation);
